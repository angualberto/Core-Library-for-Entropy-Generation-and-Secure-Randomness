â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”§ PATCH DE CORREÃ‡ÃƒO DE SEGURANÃ‡A - SERVIDOR DE AUTENTICAÃ‡ÃƒO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 1: COMPARAÃ‡ÃƒO CONSTANT-TIME
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Adicione esta funÃ§Ã£o APÃ“S as includes, ANTES das estruturas:

```c
// ComparaÃ§Ã£o constant-time para prevenir timing attacks
bool constant_time_compare(const uint8_t *a, const uint8_t *b, size_t len) {
    volatile uint8_t result = 0;
    for (size_t i = 0; i < len; i++) {
        result |= a[i] ^ b[i];
    }
    return result == 0;
}
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 2: ESTRUTURAS COM RATE LIMITING
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SUBSTITUA a estrutura User por:

```c
typedef struct {
    char username[64];
    uint8_t salt[16];
    uint8_t password_hash[32];
    bool active;
    int failed_attempts;      // NOVO
    time_t locked_until;      // NOVO
} User;
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 3: REGISTRAR USUÃRIO (SEM LOGS DE SALT)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SUBSTITUA a funÃ§Ã£o registrar_usuario() por:

```c
bool registrar_usuario(const char *username, const char *password) {
    if (user_count >= MAX_USERS) return false;
    if (encontrar_usuario(username) != NULL) return false;
    
    // VALIDAÃ‡ÃƒO DE SENHA FORTE
    size_t pass_len = strlen(password);
    if (pass_len < 12) {
        printf("âŒ Senha muito curta (mÃ­nimo 12 caracteres)\n");
        return false;
    }
    if (pass_len > 240) {
        printf("âŒ Senha muito longa (mÃ¡ximo 240 caracteres)\n");
        return false;
    }
    
    // Verificar complexidade
    bool tem_maiuscula = false, tem_minuscula = false;
    bool tem_numero = false, tem_simbolo = false;
    for (size_t i = 0; i < pass_len; i++) {
        if (isupper(password[i])) tem_maiuscula = true;
        if (islower(password[i])) tem_minuscula = true;
        if (isdigit(password[i])) tem_numero = true;
        if (!isalnum(password[i])) tem_simbolo = true;
    }
    if (!(tem_maiuscula && tem_minuscula && tem_numero && tem_simbolo)) {
        printf("âŒ Senha deve ter: maiÃºscula, minÃºscula, nÃºmero e sÃ­mbolo\n");
        return false;
    }
    
    User *user = &users[user_count];
    strncpy(user->username, username, sizeof(user->username) - 1);
    user->active = true;
    user->failed_attempts = 0;      // Inicializar
    user->locked_until = 0;         // Inicializar
    
    AGLE_Context ctx;
    AGLE_Init(&ctx);
    AGLE_GetRandomBytes(&ctx, user->salt, 16);
    
    uint8_t combined[256];
    memcpy(combined, password, pass_len);
    memcpy(combined + pass_len, user->salt, 16);
    AGLE_HashSHAKE256(combined, pass_len + 16, user->password_hash, 32);
    
    // ZEROIZAR SENHA DA MEMÃ“RIA
    memset(combined, 0, sizeof(combined));
    
    user_count++;
    
    // LOG SEGURO (SEM SALT)
    printf("âœ… UsuÃ¡rio registrado: %s\n", username);
    
    return true;
}
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 4: VALIDAR SENHA (SEM LOGS DE HASH + CONSTANT-TIME + RATE LIMIT)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SUBSTITUA a funÃ§Ã£o validar_senha() por:

```c
bool validar_senha(User *user, const char *password) {
    // VERIFICAR BLOQUEIO POR RATE LIMITING
    time_t now = time(NULL);
    if (now < user->locked_until) {
        int tempo_restante = (int)(user->locked_until - now);
        printf("ğŸ”’ Conta bloqueada: %s (aguarde %d segundos)\n", 
               user->username, tempo_restante);
        return false;
    }
    
    size_t pass_len = strlen(password);
    uint8_t combined[256];
    uint8_t hash[32];
    
    memcpy(combined, password, pass_len);
    memcpy(combined + pass_len, user->salt, 16);
    AGLE_HashSHAKE256(combined, pass_len + 16, hash, 32);
    
    // ZEROIZAR SENHA DA MEMÃ“RIA
    memset(combined, 0, sizeof(combined));
    
    // USAR COMPARAÃ‡ÃƒO CONSTANT-TIME
    bool resultado = constant_time_compare(hash, user->password_hash, 32);
    
    if (resultado) {
        // SUCESSO: Resetar contadores
        user->failed_attempts = 0;
        user->locked_until = 0;
        printf("âœ… Login bem-sucedido: %s\n", user->username);
    } else {
        // FALHA: Incrementar tentativas
        user->failed_attempts++;
        printf("âŒ Falha de login: %s (tentativa %d)\n", 
               user->username, user->failed_attempts);
        
        // RATE LIMITING EXPONENCIAL
        if (user->failed_attempts >= 5) {
            user->locked_until = now + 900;  // 15 minutos
            printf("ğŸ”’ Conta bloqueada por 15 minutos apÃ³s 5 tentativas\n");
        } else if (user->failed_attempts >= 3) {
            user->locked_until = now + 300;  // 5 minutos
            printf("ğŸ”’ Conta bloqueada por 5 minutos apÃ³s 3 tentativas\n");
        }
    }
    
    return resultado;
}
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 5: VALIDAR TOKEN (CONSTANT-TIME)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SUBSTITUA a funÃ§Ã£o validar_token() por:

```c
Session* validar_token(const char *token) {
    time_t now = time(NULL);
    
    for (int i = 0; i < session_count; i++) {
        // USAR COMPARAÃ‡ÃƒO CONSTANT-TIME PARA TOKENS
        if (sessions[i].valid && 
            constant_time_compare((uint8_t*)sessions[i].token, 
                                 (uint8_t*)token, 
                                 strlen(sessions[i].token))) {
            
            if (sessions[i].expires_at > now) {
                return &sessions[i];
            } else {
                // SessÃ£o expirada
                sessions[i].valid = false;
                printf("â° SessÃ£o expirada: %s\n", sessions[i].username);
                return NULL;
            }
        }
    }
    return NULL;
}
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 6: LIMPEZA DE SESSÃ•ES EXPIRADAS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ADICIONE esta nova funÃ§Ã£o ANTES de criar_sessao():

```c
void limpar_sessoes_expiradas() {
    time_t now = time(NULL);
    int removidas = 0;
    
    for (int i = 0; i < session_count; i++) {
        if (sessions[i].expires_at < now || !sessions[i].valid) {
            // Zeroizar dados da sessÃ£o
            memset(&sessions[i], 0, sizeof(Session));
            
            // Mover Ãºltima sessÃ£o para esta posiÃ§Ã£o
            if (i < session_count - 1) {
                sessions[i] = sessions[session_count - 1];
                i--;  // Reprocessar esta posiÃ§Ã£o
            }
            session_count--;
            removidas++;
        }
    }
    
    if (removidas > 0) {
        printf("ğŸ§¹ %d sessÃµes expiradas limpas\n", removidas);
    }
}
```

MODIFIQUE criar_sessao() para chamar a limpeza:

```c
char* criar_sessao(const char *username) {
    // LIMPAR SESSÃ•ES EXPIRADAS ANTES DE CRIAR NOVA
    limpar_sessoes_expiradas();
    
    if (session_count >= MAX_SESSIONS) return NULL;
    
    Session *sess = &sessions[session_count];
    strncpy(sess->username, username, sizeof(sess->username) - 1);
    sess->valid = true;
    sess->created_at = time(NULL);
    sess->expires_at = sess->created_at + 3600;  // 1 hora
    
    AGLE_Context ctx;
    AGLE_Init(&ctx);
    AGLE_GenerateSessionTokenHex(&ctx, sess->token, 32);
    
    session_count++;
    
    printf("âœ… SessÃ£o criada para: %s (expira em 1h)\n", username);
    
    return sess->token;
}
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 7: CORS RESTRITIVO (OPCIONAL - MAIS SEGURO)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Na funÃ§Ã£o enviar_resposta(), SUBSTITUA:

```c
"Access-Control-Allow-Origin: *\r\n"
```

Por (se servir na mesma mÃ¡quina):

```c
"Access-Control-Allow-Origin: http://localhost:8080\r\n"
```

Ou (se cliente estiver em arquivo local):

```c
"Access-Control-Allow-Origin: null\r\n"
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

PATCH 8: ADICIONAR INCLUDE PARA ctype.h (NECESSÃRIO PARA VALIDAÃ‡ÃƒO)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ADICIONE no inÃ­cio do arquivo, com os outros includes:

```c
#include <ctype.h>  // Para isupper(), islower(), isdigit(), isalnum()
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“‹ RESUMO DAS CORREÃ‡Ã•ES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… PATCH 1: ComparaÃ§Ã£o constant-time (timing attack)
âœ… PATCH 2: Estrutura com rate limiting
âœ… PATCH 3: Registro sem exposiÃ§Ã£o de salt + validaÃ§Ã£o senha forte
âœ… PATCH 4: ValidaÃ§Ã£o com rate limiting + constant-time
âœ… PATCH 5: Token constant-time
âœ… PATCH 6: Limpeza de sessÃµes expiradas
âœ… PATCH 7: CORS restritivo
âœ… PATCH 8: Include necessÃ¡rio

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âš ï¸  IMPORTANTE APÃ“S APLICAR OS PATCHES:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. RECOMPILAR: gcc -o servidor_auth servidor_auth.c -lm -Wall -Wextra
2. TESTAR todas as funcionalidades
3. Senhas antigas NÃƒO funcionarÃ£o (estrutura mudou)
4. Registrar novos usuÃ¡rios com senhas fortes:
   - MÃ­nimo 12 caracteres
   - Pelo menos: 1 MAIÃšSCULA, 1 minÃºscula, 1 nÃºmero, 1 !@#$%
   - Exemplo: MyP@ssw0rd2025!

5. Testar bloqueio:
   - 3 tentativas erradas = 5 minutos de bloqueio
   - 5 tentativas erradas = 15 minutos de bloqueio

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ” VULNERABILIDADES RESTANTES (NECESSITAM MAIS TRABALHO):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âŒ HTTPS/TLS (nÃ£o corrigido - necessita openSSL)
âŒ 2FA (nÃ£o implementado - necessita TOTP)
âŒ PersistÃªncia em DB (nÃ£o implementado - necessita SQLite)
âŒ Logging de auditoria (nÃ£o implementado)
âŒ mlock() para proteÃ§Ã£o de memÃ³ria (nÃ£o implementado)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
